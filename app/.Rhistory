install.packages("shiny")
install.packages("shiny")
install.packages("shiny")
wd()
wd
getwd()
shiny::runApp()
View(kc2)
knitr::opts_chunk$set(echo = TRUE)
saveRDS(kc2, file = "kc.rds")
saveRDS(kc2, file = "kc.rds")
kingcounty <- readRDS("data/kc.rds")
runApp()
runApp()
runApp()
lm = lm(logprice ~ bedrooms + bathrooms, data = kc)
runApp()
predict(lm, newdata = c(input$bedrooms, input$bathrooms))
?predict
predict(lm, newdata = c(2,3))
lm = lm(logprice ~ bedrooms + bathrooms, data = kc)
predict(lm, newdata = c(2,3))
lm = lm(logprice ~ bedrooms + bathrooms, data = kc)
df = data.frame("bedrooms" = 2, "bathrooms" = 3)
predict(lm, newdata = df)
runApp()
runApp()
saveRDS(kc, file = "data/kc.RDS")
saveRDS(kc, file = "data/kc.rds")
saveRDS(kc, file = "data/kc.rds")
saveRDS(kc, file = "kc.rds")
rm(list=ls)
rm(list=ls())
kingcounty <- readRDS("data/kc.rds")
lm = lm(logprice ~ bedrooms + bathrooms, data = kc)
lm = lm(logprice ~ bedrooms + bathrooms, data = kingcounty)
log(5)
exp(log(5))
runApp()
x = predict(lm, newdata = df)
x = predict(lm, newdata = df)
lm = lm(logprice ~ bedrooms + bathrooms, data = kingcounty)
df = data.frame("bedrooms" = 2, "bathrooms" = 3)
x = predict(lm, newdata = df)
lm$coefficients
x = predict(lm, newdata = df, interval="confidence", level = 0.95)
x
x[1]
x["fit"]
names(x)
x
x$fit
x[1]
x[2]
x[3]
runApp()
kc = read.csv("kc_house_data.csv")
runApp()
runApp()
runApp()
as.numeric(c("TRUE","FALSE"))
as.numeric(c("TRUE","FALSE"))
as.integer(as.logical(c("TRUE","FALSE"))
as.integer(as.logical(c("TRUE","FALSE"))
as.integer(as.logical(c("TRUE","FALSE")))
runApp()
runApp()
mean(kc$view)
mean(kc$view)
median(kc$view)
median(kc$condition)
median(kc$grade)
median(kc$yr_built)
median(kc$yr_renovated)
#import data
library(dplyr)
rm(list=ls())
kc = read.csv("kc_house_data.csv")
median(kc$zipcode)
#transforms
kc$id = NULL
kc$date = as.Date(kc$date, format="%Y%m%d")
kc$logprice = log(kc$price)
sum(kc$sqft_living - (kc$sqft_above + kc$sqft_basement)) #collinearity issue -- will drop the sum(?)
kc$sqft_living = NULL
hist(kc$sqft_basement, breaks=100) # FYI its non-normal
#should I create a binary variable for having a basement?
kc$age = 2015 - kc$yr_built
kc$yr_built = NULL
count(kc, yr_renovated) #how to handle bunching at 0s?
#kc = kc %>%
#  mutate(yr_renovated = replace(yr_renovated, yr_renovated==0, NA))
#kc$yrs_since_renovation = 2015 - kc$yr_renovated
#kc$zipcode = as.factor(kc$zipcode)
#may want to come back and cluster based on lat / lon to get neighborhood
#cor(dplyr::select_if(kc, is.numeric))
median(kc$zipcode)
runApp()
runApp()
(253.79 - 168.83)/168.83
1+ (253.79 - 168.83)/168.83
runApp()
runApp()
runApp()
if(x>0,1,0)
x = c(0,0,50)
if(x>0,1,0)
?if
x = c(0,0,50)
x = c(0,0,50)
replace(x, x>0, 1)
kc$renovated = replace(input$yr_renovated, input$yr_renovated>0, 1)
kc$renovated = replace(kc$yr_renovated, kc$yr_renovated>0, 1)
kc$age_since_ren_or_build = 2015 - max(input$yr_built,input$yr_renovated)
kc$age_since_ren_or_build = 2015 - max(kc$yr_built,kc$yr_renovated)
kc = read.csv("kc_house_data.csv")
saveRDS(kc,file="kingcounty.rds")
kingcounty = read.csv("kc_house_data.csv")
#import data
library(dplyr)
rm(list=ls())
kc = read.csv("kc_house_data.csv")
#transforms
kc$id = NULL
kc$date = as.Date(kc$date, format="%Y%m%d")
kc$logprice = log(kc$price)
#sum(kc$sqft_living - (kc$sqft_above + kc$sqft_basement)) #collinearity issue -- will drop the sum(?)
kc$sqft_living = NULL
#hist(kc$sqft_basement, breaks=100) # FYI its non-normal
kc$basement = replace(kc$sqft_basement, kc$sqft_basement>0, 1)
kc$age = 2015 - kc$yr_built
kc$yr_built = NULL
kc$age_since_ren_or_build = 2015 - max(input$yr_built,input$yr_renovated)
#import data
library(dplyr)
rm(list=ls())
kc = read.csv("kc_house_data.csv")
#transforms
kc$id = NULL
kc$date = as.Date(kc$date, format="%Y%m%d")
kc$logprice = log(kc$price)
#sum(kc$sqft_living - (kc$sqft_above + kc$sqft_basement)) #collinearity issue -- will drop the sum(?)
kc$sqft_living = NULL
#hist(kc$sqft_basement, breaks=100) # FYI its non-normal
kc$basement = replace(kc$sqft_basement, kc$sqft_basement>0, 1)
kc$age = 2015 - kc$yr_built
kc$yr_built = NULL
kc$age_since_ren_or_build = 2015 - max(kc$yr_built,kc$yr_renovated)
kc$renovated = replace(kc$yr_renovated, kc$yr_renovated>0, 1)
kc$zipcode = as.factor(kc$zipcode)
#may want to come back and cluster based on lat / lon to get neighborhood
#cor(dplyr::select_if(kc, is.numeric))
lm = lm(logprice ~ bedrooms + bathrooms + sqft_above + sqft_basement + basement + sqft_lot + floors + waterfront + view + condition + grade + age + age_since_ren_or_build + renovated + zipcode, data = kc)
summary(lm)
library(car)
hist(lm$residuals, breaks = 100)
qqPlot(lm)
plot(lm$fitted.values, lm$residuals,
xlab = "Fitted values (y-hat)",
ylab = "Residuals")
vif(lm)
plot(lm, 4)
plot(lm, 5)
kc[15871,]
plot(kc$logprice ~ kc$age)
?plot
scatterplot(kc$logprice ~ kc$age)
library(car)
scatterplot(kc$logprice ~ kc$age)
scatterplot(kc$logprice ~ kc$age)
#import data
library(dplyr)
library(car)
rm(list=ls())
kc = read.csv("kc_house_data.csv")
#transforms
kc$id = NULL
kc$date = as.Date(kc$date, format="%Y%m%d")
kc$logprice = log(kc$price)
#sum(kc$sqft_living - (kc$sqft_above + kc$sqft_basement)) #collinearity issue -- will drop the sum(?)
kc$sqft_living = NULL
#hist(kc$sqft_basement, breaks=100) # FYI its non-normal
kc$basement = replace(kc$sqft_basement, kc$sqft_basement>0, 1)
kc$age = 2015 - kc$yr_built
#scatterplot(kc$logprice ~ kc$age)
kc$age_2 = kc$age^2
kc$age_since_ren_or_build = 2015 - max(kc$yr_built,kc$yr_renovated)
kc$renovated = replace(kc$yr_renovated, kc$yr_renovated>0, 1)
kc$zipcode = as.factor(kc$zipcode)
#age squared
#collinear
#may want to come back and cluster based on lat / lon to get neighborhood
#cor(dplyr::select_if(kc, is.numeric))
lm = lm(logprice ~ bedrooms + bathrooms + sqft_above + sqft_basement + basement + sqft_lot + floors + waterfront + view + condition + grade + age + age_since_ren_or_build + renovated + zipcode, data = kc)
summary(lm)
kc[,c("yr_built","yr_renovated","age","age_since_ren_or_build")]
2015 - max(kc$yr_built,kc$yr_renovated)
#import data
library(dplyr)
library(car)
rm(list=ls())
kc = read.csv("kc_house_data.csv")
#transforms
kc$id = NULL
kc$date = as.Date(kc$date, format="%Y%m%d")
kc$logprice = log(kc$price)
#sum(kc$sqft_living - (kc$sqft_above + kc$sqft_basement)) #collinearity issue -- will drop the sum(?)
kc$sqft_living = NULL
#hist(kc$sqft_basement, breaks=100) # FYI its non-normal
kc$basement = replace(kc$sqft_basement, kc$sqft_basement>0, 1)
kc$age = 2015 - kc$yr_built
#scatterplot(kc$logprice ~ kc$age)
kc$age_2 = kc$age^2
kc$age_since_ren_or_build = 2015 - pmax(kc$yr_built,kc$yr_renovated)
kc$renovated = replace(kc$yr_renovated, kc$yr_renovated>0, 1)
kc$zipcode = as.factor(kc$zipcode)
#age squared
#collinear
#may want to come back and cluster based on lat / lon to get neighborhood
#cor(dplyr::select_if(kc, is.numeric))
kc[,c("yr_built","yr_renovated","age","age_since_ren_or_build")]
lm = lm(logprice ~ bedrooms + bathrooms + sqft_above + sqft_basement + basement + sqft_lot + floors + waterfront + view + condition + grade + age + age_2 + age_since_ren_or_build + renovated + zipcode, data = kc)
summary(lm)
vif(lm)
plot(lm, 4)
plot(lm, 5)
kc[15871,] #typo - this is 3 bedrooms
kc[15871,"bedrooms"] = 3
kc["12778",] #really expensive horse farm - going to drop
kc["7648",] #crazy large lot -- may be true but let's drop
kc["17320",] #again, very large lot for a cheap price - drop
kc = kc[!rownames(kc) %in% c("12778","7648","17320"), ]
my_lm = function(kc) {
lm = lm(logprice ~ bedrooms + bathrooms + sqft_above + sqft_basement + basement + sqft_lot + floors + waterfront + view + condition + grade + age + age_2 + age_since_ren_or_build + renovated + zipcode, data = kc)
return(lm)
}
lm = my_lm(kc)
summary(lm)
lm = my_lm(kc)
saveRDS(kingcounty,file="kingcounty.rds")
saveRDS(kc,file="kingcounty.rds")
saveRDS(lm,file="lm")
saveRDS(kc,file="kingcounty.rds")
saveRDS(lm,file="lm.rds")
runApp()
runApp()
runApp()
test
runApp()
input = data.frame("bedrooms" = 2, "bathrooms" = 3, "sqft_lot"=1234, "floors"=3, "waterfront"=as.integer(as.logical(FALSE)), "view"=0, "condition"=2, "grade"=7, "sqft_above"=2345, "sqft_basement"=0, "yr_built" = 1955, "yr_renovated" =1975, "zipcode" = 98065) #, "lat"=input$lat, "long"=input$long
input = data.frame("bedrooms" = 2, "bathrooms" = 3, "sqft_lot"=1234, "floors"=3, "waterfront"=as.integer(as.logical(FALSE)), "view"=0, "condition"=2, "grade"=7, "sqft_above"=2345, "sqft_basement"=0, "yr_built" = 1955, "yr_renovated" =1975, "zipcode" = 98065) #, "lat"=input$lat, "long"=input$long
input = data.frame("bedrooms" = 2, "bathrooms" = 3, "sqft_lot"=1234, "floors"=3, "waterfront"=FALSE, "view"=0, "condition"=2, "grade"=7, "sqft_above"=2345, "sqft_basement"=0, "yr_built" = 1955, "yr_renovated" =1975, "zipcode" = 98065) #, "lat"=input$lat, "long"=input$long
df = data.frame("bedrooms" = input$bedrooms, "bathrooms" = input$bathrooms, "sqft_lot"=input$sqft_lot, "floors"=input$floors, "waterfront"=as.integer(as.logical(input$waterfront)), "view"=input$view, "condition"=input$condition, "grade"=input$grade, "sqft_above"=input$sqft_above, "sqft_basement"=input$sqft_basement, "basement" = replace(input$sqft_basement, input$sqft_basement>0, 1), "age" = 2015 - input$yr_built, "age_2" = (2015 - input$yr_built)^2, "age_since_ren_or_build" = 2015 - pmax(input$yr_built,input$yr_renovated), "renovated" = replace(input$yr_renovated, input$yr_renovated>0, 1), "zipcode"=as.factor(input$zipcode)) #, "lat"=input$lat, "long"=input$long
#predict housing prices using lm
pred_log_price = predict(lm, newdata = df, interval="confidence", level = 0.95)
pred_log_price = predict(lm, newdata = df, interval="confidence", level = 0.95)
lm = my_lm(kc)
#troubleshooting
input = data.frame("bedrooms" = 2, "bathrooms" = 3, "sqft_lot"=1234, "floors"=3, "waterfront"=FALSE, "view"=0, "condition"=2, "grade"=7, "sqft_above"=2345, "sqft_basement"=0, "yr_built" = 1955, "yr_renovated" =1975, "zipcode" = 98065) #, "lat"=input$lat, "long"=input$long
df = data.frame("bedrooms" = input$bedrooms, "bathrooms" = input$bathrooms, "sqft_lot"=input$sqft_lot, "floors"=input$floors, "waterfront"=as.integer(as.logical(input$waterfront)), "view"=input$view, "condition"=input$condition, "grade"=input$grade, "sqft_above"=input$sqft_above, "sqft_basement"=input$sqft_basement, "basement" = replace(input$sqft_basement, input$sqft_basement>0, 1), "age" = 2015 - input$yr_built, "age_2" = (2015 - input$yr_built)^2, "age_since_ren_or_build" = 2015 - pmax(input$yr_built,input$yr_renovated), "renovated" = replace(input$yr_renovated, input$yr_renovated>0, 1), "zipcode"=as.factor(input$zipcode)) #, "lat"=input$lat, "long"=input$long
#predict housing prices using lm
pred_log_price = predict(lm, newdata = df, interval="confidence", level = 0.95)
runApp()
pred_price = 570000
percentile = (kc$price < pred_price)/nrow(kc)
pred_price = 570000
(kc$price < pred_price)/nrow(kc)
sum(kc$price < pred_price)
sum(kc$price < pred_price)/nrow(kc)
round(sum(kc$price < pred_price)/nrow(kc)*100,0)
runApp()
runApp()
install.packages(c("ggmap", "gridExtra"))
knitr::opts_chunk$set(echo = TRUE)
library("ggmap")
install.packages("ggmap")
library("ggmap")
register_google(key = "AIzaSyAN7hRaUQQGXahdx3wt-1ff-eoZsXs5Aps")
qmplot(lat, long, data = kc, source="google", maptype="terrain", geom = "blank") +
geom_point(color="#4C85EB", alpha = .3) +
geom_density_2d(color = "#000000")
library("ggmap")
register_google(key = "AIzaSyAN7hRaUQQGXahdx3wt-1ff-eoZsXs5Aps")
qmplot(lat, long, data = kc, source="google", maptype="terrain", geom = "blank") +
geom_point(color="#4C85EB", alpha = .3) +
geom_density_2d(color = "#000000")
hist(kc$lat)
hist(kc$long)
hist(kc$lat)
qmplot(long, lat, data = kc, source="google", maptype="terrain", geom = "blank") +
geom_point(color="#4C85EB", alpha = .3) +
geom_density_2d(color = "#000000")
qmplot(long, lat, data = kc, source="google", maptype="terrain", geom = "blank") +
geom_density_2d(color = "#000000")
qmplot(long, lat, data = kc, source="google", maptype="terrain", geom = "blank", zoom = 13) +
geom_density_2d(color = "#000000")
qmplot(long, lat, data = kc, source="google", maptype="terrain", geom = "blank", zoom = 8) +
geom_density_2d(color = "#000000")
qmplot(long, lat, data = kc, source="google", maptype="terrain", geom = "blank", zoom = 9) +
geom_density_2d(color = "#000000")
qmplot(long, lat, data = kc, source="google", maptype="terrain", geom = "blank", zoom = 10) +
geom_density_2d(color = "#000000")
qmplot(long, lat, data = kc, source="google", maptype="terrain", geom = "blank", zoom = 9) +
geom_density_2d(color = "#000000")
qmplot(long, lat, data = kc, source="google", maptype="terrain", geom = "blank", zoom = 9, extent = "normal") +
geom_density_2d(color = "#000000")
qmplot(long, lat, data = kc, source="google", maptype="terrain", geom = "blank", zoom = 9, extent = "panel") +
geom_density_2d(color = "#000000")
qmplot(long, lat, data = kc, source="google", maptype="terrain", geom = "blank", zoom = 9, extent = "panel", (center = c(lon = -122.197955, lat = 47.507353)) +
geom_density_2d(color = "#000000")
qmplot(long, lat, data = kc, source="google", maptype="terrain", geom = "blank", zoom = 9, extent = "panel", center = c(lon = -122.197955, lat = 47.507353)) +
qmplot(long, lat, data = kc, source="google", maptype="terrain", geom = "blank", zoom = 9, extent = "panel", center = c(lon = -122.197955, lat = 47.507353)) +
geom_density_2d(color = "#000000")
library("ggmap")
register_google(key = "AIzaSyAN7hRaUQQGXahdx3wt-1ff-eoZsXs5Aps")
qmplot(long, lat, data = kc, source="google", maptype="terrain", geom = "blank", zoom = 9, extent = "panel", center = c(lon = -122.197955, lat = 47.507353), size = c(640,640)) +
geom_density_2d(color = "#000000")
library("ggmap")
register_google(key = "AIzaSyAN7hRaUQQGXahdx3wt-1ff-eoZsXs5Aps")
qmplot(long, lat, data = kc, source="google", maptype="terrain", geom = "blank", zoom = 9, extent = "panel", center = c(lon = -122.197955, lat = 47.507353)) +
geom_density_2d(color = "#000000")
library("ggmap")
register_google(key = "AIzaSyAN7hRaUQQGXahdx3wt-1ff-eoZsXs5Aps")
qmplot(long, lat, data = kc, source="google", maptype="terrain", geom = "blank", zoom = 9, extent = "panel", center = c(lon = -122.197955, lat = 47.507353),  size = I(3.5)) +
geom_density_2d(color = "#000000")
library("ggmap")
register_google(key = "AIzaSyAN7hRaUQQGXahdx3wt-1ff-eoZsXs5Aps")
qmplot(long, lat, data = kc, source="google", maptype="terrain", geom = "blank", zoom = 9, extent = "panel", center = c(lon = -122.197955, lat = 47.507353),  size = I(10)) +
geom_density_2d(color = "#000000")
library("ggmap")
register_google(key = "AIzaSyAN7hRaUQQGXahdx3wt-1ff-eoZsXs5Aps")
qmplot(long, lat, data = kc, source="google", maptype="terrain", geom = "blank", zoom = 9, extent = "panel", xlim = c(-122.5,-121.8), ylim = c(47.2,47.8)) +
geom_density_2d(color = "#000000")
km = kmeans(kc[c("lat","long")],11)
kc$neighborhood = as.factor(km$cluster) #assign the cluster labs
map = get_map(location='seattle', zoom=10, maptype = "terrain", source='google', color='bw')
ggmap(map) + geom_point(data = kc, aes(x=long, y=lat, color=neighborhood))
km = kmeans(kc[c("lat","long")],25)
kc$neighborhood = as.factor(km$cluster) #assign the cluster labs
sample = sample(kc, size = 1000)
km = kmeans(kc[c("lat","long")],25)
kc$neighborhood = as.factor(km$cluster) #assign the cluster labs
sample_index = sort(sample(seq_len(nrow(kc)), replace = FALSE, size = 1000))
sample = kc[train_index,]
km = kmeans(kc[c("lat","long")],25)
kc$neighborhood = as.factor(km$cluster) #assign the cluster labs
sample_index = sort(sample(seq_len(nrow(kc)), replace = FALSE, size = 1000))
sample = kc[sample_index,]
map = get_map(location='seattle', zoom=10, maptype = "terrain", source='google', color='bw')
ggmap(map) + geom_point(data = sample, aes(x=long, y=lat, color=neighborhood))
map = get_map(location='seattle', zoom=10, maptype = "terrain", source='google', color='bw')
ggmap(map) + geom_point(data = sample, aes(x=long, y=lat, color=zipcode))
km = kmeans(kc[c("lat","long")],30)
kc$neighborhood = as.factor(km$cluster) #assign the cluster labs
sample_index = sort(sample(seq_len(nrow(kc)), replace = FALSE, size = 1000))
sample = kc[sample_index,]
map = get_map(location='seattle', zoom=10, maptype = "terrain", source='google', color='bw')
ggmap(map) + geom_point(data = sample, aes(x=long, y=lat, color=neighborhood))
km = kmeans(kc[c("lat","long")],50)
kc$neighborhood = as.factor(km$cluster) #assign the cluster labs
sample_index = sort(sample(seq_len(nrow(kc)), replace = FALSE, size = 1000))
sample = kc[sample_index,]
map = get_map(location='seattle', zoom=10, maptype = "terrain", source='google', color='bw')
ggmap(map) + geom_point(data = sample, aes(x=long, y=lat, color=neighborhood))
#troubleshooting
input = data.frame("bedrooms" = 2, "bathrooms" = 3, "sqft_lot"=1234, "floors"=3, "waterfront"=FALSE, "view"=0, "condition"=2, "grade"=7, "sqft_above"=2345, "sqft_basement"=0, "yr_built" = 1955, "yr_renovated" =1975, "zipcode" = 98065, "lat" = 47.591985, "long" = -122.175203)
df = data.frame("bedrooms" = input$bedrooms, "bathrooms" = input$bathrooms, "sqft_lot"=input$sqft_lot, "floors"=input$floors, "waterfront"=as.integer(as.logical(input$waterfront)), "view"=input$view, "condition"=input$condition, "grade"=input$grade, "sqft_above"=input$sqft_above, "sqft_basement"=input$sqft_basement, "basement" = replace(input$sqft_basement, input$sqft_basement>0, 1), "age" = 2015 - input$yr_built, "age_2" = (2015 - input$yr_built)^2, "age_since_ren_or_build" = 2015 - pmax(input$yr_built,input$yr_renovated), "renovated" = replace(input$yr_renovated, input$yr_renovated>0, 1), "zipcode"=as.factor(input$zipcode), "lat"=input$lat, "long"=input$long)
#predict housing prices using lm
pred_log_price = predict(lm, newdata = df, interval="confidence", level = 0.95)
my_lm = function(kc) {
lm = lm(logprice ~ bedrooms + bathrooms + sqft_above + sqft_basement + basement + sqft_lot + floors + waterfront + view + condition + grade + age + age_2 + age_since_ren_or_build + renovated + neighborhood, data = kc)
return(lm)
}
lm = my_lm(kc)
summary(lm)
vif(lm)
runApp()
saveRDS(kc,file="kingcounty.rds")
saveRDS(lm,file="lm.rds")
runApp()
install.packages("geosphere")
library(geosphere)
kc %>%
rowwise() %>%
distm(c(input$long, input$lat), c(lon2, lat2), fun = distHaversine)
distm(c(input$long, input$lat), c(sample$lon2, sample$lat2), fun = distHaversine)
map_lgl(sample, distm(c(input$long, input$lat), c(lon2, lat2), fun = distHaversine))
library(purrr)
map_int(sample, distm(c(input$long, input$lat), c(lon2, lat2), fun = distHaversine))
map_int(sample, distm(c(input$long, input$lat), c(sample$lon2, sample$lat2), fun = distHaversine))
dist_matrix = NULL
for (i in c(1:nrow(sample))) {
dist_matrix[i] = distm(c(input$long, input$lat), c(sample$lon2, sample$lat2), fun = distHaversine)
}
dist_matrix = NULL
for (i in c(1:nrow(sample))) {
dist_matrix[i] = distm(c(input$long, input$lat), c(sample$long, sample$lat), fun = distHaversine)
}
c(input$long, input$lat)
dist_matrix = NULL
for (i in c(1:nrow(sample))) {
dist_matrix[i] = distm(c(input$long, input$lat), c(sample$long[i], sample$lat[i]), fun = distHaversine)
}
hist(dist_matrix)
head(arrange(dist_matrix))
arrange(dist_matrix)
head(sort(dist_matrix))
sort(dist_matrix)
dist_matrix
head(sort(dist_matrix))
names(head(sort(dist_matrix)))
rownames(head(sort(dist_matrix)))
rownames(sort(dist_matrix))
rownames(dist_matrix)
dist_matrix
dist_matrix = NULL
for (i in c(1:nrow(sample))) {
dist_matrix[i] = distm(c(input$long, input$lat), c(sample$long[i], sample$lat[i]), fun = distHaversine)
}
rownames(dist_matrix)
dist_matrix = as.matrix(NULL)
dist_matrix = as.data.frame("i"=c(1:nrow(sample),"dist"=rep(NA,nrow(sample))))
rep(NA,nrow(sample))
dist_matrix = as.data.frame("i"=c(1:nrow(sample)),"dist"=rep(NA,nrow(sample))))
dist_matrix = as.data.frame("i"=c(1:nrow(sample)),"dist"=rep(NA,nrow(sample)))
dist_matrix = as.data.frame("i"=c(1:nrow(sample)),"dist"=rep(NA,nrow(sample)))
c(1:nrow(sample))
dist_matrix = data.frame("i"=c(1:nrow(sample)),"dist"=rep(NA,nrow(sample)) )
dist_matrix = data.frame("i"=c(1:nrow(sample)),"dist"=rep(NA,nrow(sample)) )
for (i in c(1:nrow(sample))) {
dist_matrix[i,"dist"] = distm(c(input$long, input$lat), c(sample$long[i], sample$lat[i]), fun = distHaversine)
}
head(arrange(dist_matrix, dist))
?head
head(arrange(dist_matrix, dist), n = 15)
arrange(dist_matrix, dist)
head(arrange(dist_matrix, dist), n = 15)
head(arrange(dist_matrix, dist), n = 15)$i
top_neighbors = head(arrange(dist_matrix, dist), n = 15)$i
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
kc[closest_15_neighbors,"neighborhood"])
median(kc[top_neighbors,"neighborhood"])
kc[top_neighbors,"neighborhood"]
median(as.integer(kc[top_neighbors,"neighborhood"]))
runApp()
dist_matrix = data.frame("i"=c(1:nrow(kingcounty)),"dist"=rep(NA,nrow(kingcounty)) )
kingcounty = readRDS("data/kingcounty.rds")
dist_matrix = data.frame("i"=c(1:nrow(kingcounty)),"dist"=rep(NA,nrow(kingcounty)) )
for (i in c(1:nrow(kingcounty))) {
dist_matrix[i,"dist"] = distm(c(input$long, input$lat), c(kingcounty$long[i], kingcounty$lat[i]), fun = distHaversine)
}
head(arrange(dist_matrix, dist), n = 15)
head(arrange(dist_matrix, dist), n = 15)$i
top_neighbors = head(arrange(dist_matrix, dist), n = 15)$i
median(as.integer(kc[top_neighbors,"neighborhood"]))
as.integer(kc[top_neighbors,"neighborhood"])
median(as.integer(kc[top_neighbors,"neighborhood"]))
runApp()
df$neighborhood = as.factor(median(as.integer(kc[top_neighbors,"neighborhood"])))
lm = my_lm(kc)
pred_log_price = predict(lm, newdata = df, interval="confidence", level = 0.95)
library(geosphere)
library(shiny)
library(geosphere)
runApp()
runif(1,0,3000)
runif(1,0,3000)
runif(1,0,3000)
library(dpylr)
library(dplyr)
runApp()
runApp()
runApp()
runApp()
knitr::opts_chunk$set(echo = TRUE)
read.delim("my_key")
read.delim("my_key.txt")
x = read.delim("my_key.txt")
print(x)
read.delim("my_key.txt")
read.delim("my_key.txt".choose())
read.delim("/my_key.txt")
read.delim("/my_key.txt")
read.delim(file.choose("my_key.txt"))
wd()
pwd()
getwd()
?read.delim
getwd()
x = read.delim("my_key.txt")
x = read.delim("my_key.txt")
x = read.delim("my_key.txt")
x = read.delim("my_key.txt")
x = read.delim("my_key.txt")
x = read.delim("my_key.txt")
x
x = string(read.delim("my_key.txt"))
read.delim("my_key.txt")[1]
x = read.delim("my_key.txt")
read.delim("my_key.txt", header = FALSE)
read.delim("my_key.txt", header = FALSE)[1]
x = read.delim("my_key.txt", header = FALSE)[1,]
x = read.delim("my_key.txt", header = FALSE)[1,]
x = str(read.delim("my_key.txt", header = FALSE)[1,])
x
x = read.delim("my_key.txt", header = FALSE)[1,]
x = as.character(read.delim("my_key.txt", header = FALSE)[1,])
